import { GrammarPoints, many, option, range, special, toDefs, union } from '../grammar'
import { tokens as tk, tokens } from './refs'

const _defs: Record<keyof typeof tk, GrammarPoints> = {
	character: special('any unicode character'),
	commentCharacter: special('any Unicode character except new line (U+000A)'),
	charCharacter: special("any Unicode character except \\ (U+005C), new line (U+000A) and ' (U+0027)"),
	stringCharacter: special('any Unicode character except \\ (U+005C) and " (U+201D)'),
	whitespaceCharacter: special(
		'space (U+0020), tab (U+0009), vertical tab (U+000B), form feed (U+000C) and carriage return (U+000D)'
	),
	letter: special('any character in the Unicode category Ll, Lm, Lt, Lu or Lo'),
	digit: special('any character in the Unicode category Nd'),
	binaryDigit: union('0', '1'),
	decimalDigit: range('0', '9'),
	hexDigit: union(tk.decimalDigit, range('a', 'f'), range('A', 'F')),
	decimalBody: [tk.decimalDigit, many(union(tk.underscore, tk.decimalDigit))],
	binaryBody: [tk.binaryDigit, many(union(tk.underscore, tk.binaryDigit))],
	hexBody: [tk.hexDigit, many(union(tk.underscore, tk.hexDigit))],
	floatExponent: [union('e', 'E'), option(union(tk.plus, tk.minus)), tk.decimalBody],
	decimalLiteral: [tk.decimalBody],
	binaryLiteral: ['0', union('b', 'B'), tk.binaryBody],
	hexLiteral: ['0', union('x', 'X'), tk.hexBody],
	intLiteral: union(tk.binaryLiteral, tk.decimalLiteral, tk.hexLiteral),
	floatLiteral: [tk.decimalBody, tk.dot, tk.decimalBody, option(tk.floatExponent)],
	boolLiteral: union(tk.trueKw, tk.falseKw),
	escapedChar: ['\\', union('n', 't', 'v', 'f', 'r', "'", '"', '\\')],
	charLiteral: [tk.apostrophe, union(tk.escapedChar, tokens.charCharacter), tk.apostrophe],
	stringLiteral: [tk.quote, many(union(tk.escapedChar, tokens.stringCharacter)), tk.quote],
	newline: special('the new line character (U+000A)'),
	commaOrNL: union(tk.comma, tk.newline),
	lineComment: ['//', many(tokens.commentCharacter)],
	multiComment: ['/*', many(union(tk.multiComment, tokens.character)), '*/'],
	comment: union(tk.lineComment, tk.multiComment),
	identifierHead: union(tokens.letter, tk.underscore),
	identifierTail: union(tokens.letter, tk.underscore, tokens.digit, tk.apostrophe),
	identifier: [tk.identifierHead, many(tk.identifierTail), option(tk.underscore, tk.eq)],
	whitespace: many(tokens.whitespaceCharacter),
	eof: special('end of the file'),
	classKw: 'class',
	traitKw: 'trait',
	defKw: 'def',
	valKw: 'val',
	varKw: 'var',
	importKw: 'import',
	thisKw: 'this',
	superKw: 'super',
	whereKw: 'where',
	nullKw: 'null',
	trueKw: 'true',
	falseKw: 'false',
	apostrophe: "'",
	quote: '"',
	lParen: '(',
	rParen: ')',
	lBracket: '[',
	rBracket: ']',
	lBrace: '{',
	rBrace: '}',
	plus: '+',
	minus: '-',
	star: '*',
	slash: '/',
	and: '&',
	andAnd: '&&',
	pipePipe: '||',
	less: '<',
	greater: '>',
	lessEq: '<=',
	greaterEq: '>=',
	eq: '=',
	eqEq: '==',
	qMark: '?',
	eMarkEq: '!=',
	colon: ':',
	subtype: '<:',
	supertype: '>:',
	arrow: '->',
	dot: '.',
	comma: ',',
	underscore: '_',
	PistonToken: union(
		tk.intLiteral,
		tk.floatLiteral,
		tk.boolLiteral,
		tk.charLiteral,
		tk.stringLiteral,
		tk.thisKw,
		tk.superKw,
		tk.nullKw,
		tk.identifier,
		tk.whereKw,
		tk.importKw,
		tk.valKw,
		tk.varKw,
		tk.defKw,
		tk.classKw,
		tk.traitKw,
		tk.comment,
		tk.whitespace,
		tk.newline,
		tk.eof,
		tk.eq,
		tk.eqEq,
		tk.eMarkEq,
		tk.less,
		tk.greater,
		tk.lessEq,
		tk.greaterEq,
		tk.andAnd,
		tk.pipePipe,
		tk.plus,
		tk.minus,
		tk.star,
		tk.slash,
		tk.dot,
		tk.comma,
		tk.qMark,
		tk.lParen,
		tk.rParen,
		tk.lBracket,
		tk.rBracket,
		tk.lBrace,
		tk.rBrace,
		tk.colon,
		tk.arrow,
		tk.and,
		tk.subtype,
		tk.supertype
	),
}

const defs = toDefs(tk, _defs)

export default defs
